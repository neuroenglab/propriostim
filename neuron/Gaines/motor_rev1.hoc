// NTC cleaned up slightly

//load_file("nrngui.hoc") // NTC load the hoc standard run and GUI libraries here

/*--------------------------------------------------------------------

06/16
Jessica Gaines and Katharine Polasek

04/15
Lane Heyboer
Julia Slopsema

02/02
Cameron C. McIntyre

SIMULATION OF PNS MYELINATED MOTOR AXON

This model is described in detail in:

Gaines JS, Finn KE, Slopsema JP, Heyboer LA, Polasek KH. A Model of 
Motor and Sensory Axon Activation in the Median Nerve Using Surface Electrical Stimulation. Journal of Computational Neuroscience, 2018.

McIntyre CC, Richardson AG, and Grill WM. Modeling the excitability of
mammalian nerve fibers: influence of afterpotentials on the recovery
cycle. Journal of Neurophysiology 87:995-1006, 2002.


----------------------------------------------------------------------*/
objectvar file_par				// fiber and simulation parameters file
file_par=new File()

// TODO: Read in from single txt-file like with MRG, instead of four files
// objectvar file_Vext					// stimulation potential file
// file_Vext = new File()

// Read in axon properties (fiberD, num_nodes) and voltages in each axon segment

strdef node_read, mysa_read, flut_read, stin_read //, fiberD_read, num_nodes_read
objref node_volt, mysa_volt, flut_volt, stin_volt, fiberD, num_nodes, f1, f2, f3, f4 //, f5, f6
objref apc						// AP counter for a giver node (3 chosen here)
objref apc1						// AP counter for another node (5 here)

// node2check=2   //This is the node where the voltage will be checked for an action potential.

f1=new File()
f2=new File()
f3=new File()
f4=new File()
// f5=new File()
// f6=new File()

node_volt=new Vector()
mysa_volt=new Vector()
flut_volt=new Vector()
stin_volt=new Vector()
// fiberD=new Vector()
// num_nodes=new Vector()

sprint(node_read,"nodes.dat")
sprint(mysa_read,"mysas.dat")
sprint(flut_read,"fluts.dat")
sprint(stin_read,"stins.dat")
// sprint(fiberD_read,"fiberD.dat")
// sprint(num_nodes_read,"num_nodes.dat")

f1.ropen(node_read)
f2.ropen(mysa_read)
f3.ropen(flut_read)
f4.ropen(stin_read)
// f5.ropen(fiberD_read)
// f6.ropen(num_nodes_read)

node_volt.scanf(f1)
mysa_volt.scanf(f2)
flut_volt.scanf(f3)
stin_volt.scanf(f4)
// fiberD.scanf(f5)
// num_nodes.scanf(f6)

f1.close()
f2.close()
f3.close()
f4.close()
// f5.close()
// f6.close()

// Procedure to load data from files (stimulation parameters, fiber diameter and
// structure and external stmulation potential, taken from MRGaxon and modified by Ephraim
proc load_files(){    
    // Fiber parameters
    // Read in a file with following format:
	// 'D','start', 'duration', 'deltai', 'nbCurr', 
	// 'nbNod', 'nbSeg', 'nodeD', 'paraD1', 'paraD2', 
	// 'interD', 'L', 'nodeL', 'paraL1', 'paraL2', 'interL', 'nbLam'
	file_par.ropen("parameters.txt")
	
	// fiber diameter
	D = file_par.scanvar()
	// current injection start time
	start = file_par.scanvar()
	// duration of current injection
	duration = file_par.scanvar()
	// Current incrementation step size
	deltaI = file_par.scanvar()
	// maximum number of current incrementations
	nbCurr = file_par.scanvar()			// attention changé nom
	// total number of nodes of Ranvier	
	nbNod = file_par.scanvar()			// attention changé nom
	// total number of compartments (segments)
	nbSeg = file_par.scanvar()			// rajouté par moi
	// diameter of nodes of Ranvier
	nodeD = file_par.scanvar()
	// diameter of paranode 1 (MYSA)
	paraD1 = file_par.scanvar()
	// diameter of paranode 2 (FLUT)
	paraD2 = file_par.scanvar()
	// diameter of internode (STIN)
	interD = file_par.scanvar()			// attention changé nom
	// internodal distance
	nnL = file_par.scanvar()			// attention changé nom
	// node length
	nodeL = file_par.scanvar()			// rajouté par moi
	// length of paranode 1 (MYSA)
	paraL1 = file_par.scanvar()			// rajouté par moi, attention changé nom
	// length of paranode 2 (FLUT)
	paraL2 = file_par.scanvar()
	// total length of internodal segments
	interL = file_par.scanvar()
	// number of lamella
	nbLam = file_par.scanvar()			// attention changé nom
	
	print nbNod
	print nbSeg*(nbNod-1)+1
	file_par.close()
	
	
	// TODO: Read in from single txt-file like with MRG, instead of four files
	// // Stimulation potential
	// file_Vext.ropen("vext_data.txt")
	// V = new Vector(nbSeg*(nbNod-1)+1) 
    // for i=0,nbSeg*(nbNod-1){
		// V.x[i] = file_Vext.scanvar()
	// }
    // file_Vext.close()
}

// Load data from files (data)
load_files()

// Fiber diameter (the floating point value) is the first and only entry in the vector fiberD
// fiberDiam=fiberD.x[0]
fiberDiam=D

// The number of nodes (the integer value) is the first and only entry in the vector num_nodes
// axonnodes=num_nodes.x[0]
axonnodes=nbNod

// NTC not here--load standard run library etc. at the very start of the file
// don't bury it in the middle of other stuff
//load_file("noload.hoc")

proc model_globels() {			
	celsius=37		//degrees C//	// Human body temperature
	// v_init=-85.9411 //mV//			// starting voltage
	v_init=-84.4 //mV//			// RMP according to Howells et al. (2012)
	// v_init							// set in ExecuteSimulation
	// dt=0.01 //ms//					// time step
	// dt								// set in ExecuteSimulation
	// tstop=60 //ms//					// time at which simulation terminates
	// tstop							// set in ExecuteSimulation
	node_volt //mV              // voltage profile in the node from MAXWELL
	mysa_volt //mV              // voltage profile in the mysa from MAXWELL
	flut_volt //mV              // voltage profile in the flut from MAXWELL
	stin_volt //mV              // voltage profile in the stin from MAXWELL
	fiberDiam //um              // Diameter of the axon fiber
    num_nodes                   // Number of nodes modeled 


//Extracellular stimuluation parameters//
	delay=start //ms			// time before the stimulation is applied
	pw=duration					// pulse width, the duration of the stimulation

//topological parameters//
	paranodes1=(axonnodes-1)*2//156_40_156 (nodes-1)*2      // number of mysa segments in the axon model
	paranodes2=(axonnodes-1)*2//156_40_156 (nodes-1)*2      // number of flut segments in the axon model
	axoninter=(axonnodes-1)*6//468_120_468                  // number of stin segments in the axon model
	axontotal=axonnodes+paranodes1+paranodes2+axoninter     // total number of segments in the axon model

//morphological parameters//	
	// paralength1=3       // mysa length
	paralength1=paraL1
	// nodelength=1.0	// node length
	nodelength=nodeL
	space_p1=0.002      // mysa periaxonal space width
	space_p2=0.004      // flut periaxonal space width
	space_i=0.004       // stin periaxonal space width

//electrical parameters//	
    rhoa=0.7e6 //Ohm-um//					//axoplasmic resistivity
	mycm=0.1 //uF/cm2/lamella membrane//	// myelin capacitance
	mygm=0.001 //S/cm2/lamella membrane//	// myelin conductance
}

model_globels ()

proc dependent_var() {

	// linear interpolation of properties from McIntyre, Richardson, and Grill (2002) for any fiber diameter between 5.7 and 16 um
	g = 0.0172*(fiberDiam)+0.5076    		//??
	// axonD = 0.889*(fiberDiam)-1.9104  		//diameter of the axon
	axonD = interD
	// nodeD = 0.3449*(fiberDiam)-0.1484 		//diameter of the node
	// paraD1 = 0.3527*(fiberDiam)-0.1804		//diameter of paranode 1
	// paraD2 = 0.889*(fiberDiam)-1.9104 		//diameter of paranode 2
	// deltax = 969.3*log(fiberDiam)-1144.6		//total length between nodes (including 1/2 the node on each side)
	deltax = nnL
	// paralength2 = 2.5811*(fiberDiam)+19.59 	//length of paranode2
	paralength2 = paraL2
	// nl = 65.897*log(fiberDiam)-32.666		//number of lamella
	nl = nbLam
	
	Rpn0=(rhoa*0.01)/(PI*((((nodeD/2)+space_p1)^2)-((nodeD/2)^2)))
	
	Rpn1=(rhoa*0.01)/(PI*((((paraD1/2)+space_p1)^2)-((paraD1/2)^2)))
	
	Rpn2=(rhoa*0.01)/(PI*((((paraD2/2)+space_p2)^2)-((paraD2/2)^2)))
	
	Rpx=(rhoa*0.01)/(PI*((((axonD/2)+space_i)^2)-((axonD/2)^2)))
	
	// interlength=(deltax-nodelength-(2*paralength1)-(2*paralength2))/6
	interlength=interL

//axonD=diameter of the axon
//nodeD=diameter of the node
//paraD1=diameter of paranode 1
//paraD2diameter of paranode 2
//deltax=total length between nodes (including 1/2 the node on each side)
//paralength2=length of paranode2
//n1=number of lamella

}

dependent_var()

create node[axonnodes], MYSA[paranodes1], FLUT[paranodes2], STIN[axoninter]

access node[0]	//APD

// NTC give procedures descriptive names
// avoid names with connotations that differ from what the proc actually does
// e.g. "initialize," if it were to be used at all,
// should be reserved for code that sets initial conditions
// proc initialize(){
proc modelsetup(){

	print nl
	print fiberDiam
	print axonD
	print paraD2
	print paraD1
	
	forall insert extracellular // initialize extracellular voltage source
	forall e_extracellular = 0  // set extracellular voltage source to ground
	
	for i=0,axonnodes-1 {

		node[i]{
			nseg=1
			diam=nodeD
			L=nodelength
			Ra=rhoa/10000
			cm=2
			insert node_motor		// mod file declaring nodal channel properties
			xraxial=Rpn0 xg=1e10 xc=0
			}
		}
	for i=0, paranodes1-1 {
		MYSA[i]{
			nseg=1
			diam=fiberDiam
			L=paralength1
			Ra=rhoa*(1/(paraD1/fiberDiam)^2)/10000
			cm=2*paraD1/fiberDiam
			insert mysa_motor		// mod file declaring mysa channel properties
			xraxial=Rpn1 xg=mygm/(nl*2) xc=mycm/(nl*2)
			}
	}
	for i=0, paranodes2-1 {
	
		FLUT[i]{
			nseg=1
			diam=fiberDiam 
			L=paralength2
			Ra=rhoa*(1/(paraD2/fiberDiam)^2)/10000
			cm=2*paraD2/fiberDiam	
			insert flut_motor		// mod file declaring flut channel properties
			xraxial=Rpn2 xg=mygm/(nl*2) xc=mycm/(nl*2)
			}
	}
	for i=0, axoninter-1 {

		STIN[i]{
			nseg=1
			diam=fiberDiam
			L=interlength
			Ra=rhoa*(1/(axonD/fiberDiam)^2)/10000
			cm=2*axonD/fiberDiam
			insert stin_motor		// mod file declaring stin channel properties
			xraxial=Rpx xg=mygm/(nl*2) xc=mycm/(nl*2)
			}
	}
	for i=0, axonnodes-2 {
		connect MYSA[2*i](0), node[i](1)
		connect FLUT[2*i](0), MYSA[2*i](1)

		connect STIN[6*i](0), FLUT[2*i](1)
		connect STIN[6*i+1](0), STIN[6*i](1)
		connect STIN[6*i+2](0), STIN[6*i+1](1)
		connect STIN[6*i+3](0), STIN[6*i+2](1)
		connect STIN[6*i+4](0), STIN[6*i+3](1)	
		connect STIN[6*i+5](0), STIN[6*i+4](1)	

		connect FLUT[2*i+1](0), STIN[6*i+5](1)
		connect MYSA[2*i+1](0), FLUT[2*i+1](1)
		connect node[i+1](0), MYSA[2*i+1](1)
		}
}

modelsetup()

// specification of the representation of biology is now complete

///// NTC End of model setup /////

///// instrumentation is next /////

///// extracellular stimulation

objref fih
fih = new FInitializeHandler(0, "set_e_ext(0)")

//the following procedure only gets called at t=0, t=delay, t=delay+pulsewidth//
// changes extracellular stimulation values at the beginning of of the test and at the beginning and end of the stimulation pulse
proc set_e_ext() {

	// beginning of the test
	// extracellular voltage is zero, wait for t = delay to start pulse
	if ($1 == 0) {
		forall e_extracellular = 0//set extracellular voltage source to ground
		cvode.event(delay, "set_e_ext(1)")  // when to turn on

	// during the stimulation pulse
	// set extracellular voltage to values determined by MAXWELL
	// wait for the end of the pulse (t = delay + pw)

	}else if ($1 == 1) {
		for i=0,axonnodes-1 {
			node[i]{
			// e_extracellular = node_volt.x[i]					
			e_extracellular = -node_volt.x[i]*mod_factor
				}
		}
		for i=0, paranodes1-1 {
			MYSA[i]{	
			e_extracellular = -mysa_volt.x[i]*mod_factor
				}
		}
		for i=0, paranodes2-1 {
			FLUT[i]{
			e_extracellular = -flut_volt.x[i]*mod_factor
				}
		}
		for i=0, axoninter-1 {
			STIN[i]{
			e_extracellular = -stin_volt.x[i]*mod_factor	
				}
		}			

		cvode.event(delay + pw, "set_e_ext(2)")

	// end of the stimulation pulse
	// reset extracellular stimulation to zero
	// wait for the beginning of a new test

	}else if ($1 == 2) {
		forall e_extracellular = 0
		cvode.event(0, "set_e_ext(0)")
	}
}


forall insert constant // specified in constant.mod
  // a density mechanism that delivers a constant current to each segment
  // forcing the model's resting potential to v_init
  // current is specified by range variable parameter ic

proc init() {
  finitialize(v_init)
  // exploit the fact that all sections named foo
  // have the same set of channels
  // for each section of a given type iterate over each segment
  forsec "node" for (x,0) {
    // ina, inap, ik, il, ikf
    ic_constant = -(ina_node_motor + inap_node_motor + ik_node_motor \
                    + il_node_motor + ikf_node_motor)
  }
  forsec "MYSA" for (x,0) {
    // ik, il, iq, ikf
    ic_constant = -(ik_mysa_motor + iq_mysa_motor \
                    + il_mysa_motor + ikf_mysa_motor)
  }
  forsec "FLUT" for (x,0) {
    // ik, il, iq, ikf
    ic_constant = -(ik_flut_motor + iq_flut_motor \
                    + il_flut_motor + ikf_flut_motor)
  }
  forsec "STIN" for (x,0) {
    // ik, il, iq, ikf
    ic_constant = -(ik_stin_motor + iq_stin_motor \
                    + il_stin_motor + ikf_stin_motor)
  }

  if (cvode.active()) {
    cvode.re_init()
  } else {
    fcurrent()
  }
  
  frecord_init()
}

///// spike detection

m=2  // the axon has not fired

// if the voltage is ever higher than 0 V at node node2check, call the process "handle1()"
// objref nc, nil
// node[node2check] nc = new NetCon(&v(.5), nil)
// nc.threshold = 0 // watch out! only one threshold per presyn location
// nc.record("handle1()")

// proc handle1() {
	// print "called handle1() at time ", t, " when node.v = ", node[31].v(.5)
    // m=3  // indicates that there was an action potential
	// cvode.event(t+1e-6) 
// }

// Graphs
// objectvar save_window_, rvp_
// objectvar scene_vector_[4]
// objectvar ocbox_, ocbox_list_, scene_, scene_list_
// {ocbox_list_ = new List()  scene_list_ = new List()}
// {pwman_place(0,0,0)}

// Voltage graph
// displays voltage trace at node node2check
// {
// save_window_ = new Graph(0)
// save_window_.size(0,250,-80,0)
// scene_vector_[2] = save_window_
// {save_window_.view(0, -90, tstop, 40, 347, 280, 300.48, 200.32)}
// graphList[0].append(save_window_)
// save_window_.save_name("graphList[0].")
// save_window_.addexpr("node[node2check].v( 0.5 )", 2, 1, 0.637061, 1.01022, 2)  //Where in the axon voltage is graphed
// }

/*
// Graph of mp node
// displays percentage of mp gates that are open at the point 50% of the way through node 31
{
save_window_ = new Graph(0)
save_window_.size(0,350,0,1)
scene_vector_[2] = save_window_
{save_window_.view(0, 0, 250, 1, 347, 280, 300.48, 200.32)}
graphList[2].append(save_window_)
save_window_.save_name("graphList[2].")
save_window_.addexpr("node[31].mp_node_motor_6( 0.5 )", 2, 1, 0.637061, 1.01022, 2)
}
*/

// Dispay parameters in a window
/*
{
xpanel("RunControl", 0)
xvalue("Init","v_init", 1,"stdinit()", 1, 1 )
xbutton("Init & Run","run()")
xbutton("Stop","stoprun=1")
runStopAt = 5
xvalue("Continue til","runStopAt", 1,"{continuerun(runStopAt) stoprun=1}", 1, 1 )
runStopIn = 1
xvalue("Continue for","runStopIn", 1,"{continuerun(t + runStopIn) stoprun=1}", 1, 1 )
xbutton("Single Step","steprun()")
t = 0
xvalue("t","t", 2 )
xvalue("Tstop","tstop", 1,"tstop_changed()", 0, 1 )
dt = 0.005
xvalue("dt","dt", 1,"setdt()", 0, 1 )
steps_per_ms = 40
xvalue("Points plotted/ms","steps_per_ms", 1,"setdt()", 0, 1 )
xcheckbox("Quiet",&stdrun_quiet,"")
realtime = 0
xvalue("Real Time","realtime", 0,"", 0, 1 )
xpanel(57,280)
}
objectvar scene_vector_[1]
{doNotify()}
*/

// NTC unless you know exactly what you're doing,
// don't specify/control adaptive integration with code.
// Instead, use the GUI's VariableStepControl to determine 
// which state variables need to be scaled and by how much, 
// and what the error tolerance should be.
//cvode_active(1) // optional. but fixed step will probably do one extra time step
//cvode.condition_order(2) // optional. but much more accurate event time evaluation.

// NTC don't automatically launch a simulation
// instead, use the RunControl panel to launch simulations
// in order to perform interactive exploration of the model
// run()
// replaced by ExecuteSimulation

// Function that launches simulation for one mod_factor given as input
func ExecuteSimulation(){ local id

	print "calling ExecuteSimulation"
	// Set simulation parameters		
	mod_factor = $1		// Set mod_factorlitude modulator as input parameter 1
	c = mod_factor/deltaI
	
	tstop = 1.4		// Set stopping time to 1.4ms
	dt = 0.001		// Set smod_factorling time to 0.001ms

	// Put AP counter on center of middle and end node with threshold 0mv (on v, not
	// on extracellular layers)
	// middle node
	node[int(axonnodes / 2 + .5) - 1] {
		apc = new APCount(0.5)
		apc.thresh = 0
	}
	// end node
	node[axonnodes - 1]{
		apc1 = new APCount(0.5)
		apc1.thresh = 0
	}
	access node[axonnodes - 1]
	// TODO: Configure node to read from in parameters.txt
	// Performs initialization in several steps:
	// - sets t = 0
	// - initialize all sections membrane potential with v_init (node/paranode)
	// - calls FInitializeHandlers: here we have only fih which points on the 
	//   procedure initi() 
	// - executes all INITIAL blocks of the sections mechanisms	(.mod)
	// v_init = -79.3565		// Resting potential [mV]
	
//printf("%s\n","ExecuteSimulation Pre")
//printf("%d\n",apc.n)

	
/*
//
dv = new Vector()
rect = new Vector()
//print node[2].v(.5)
dv.record(&node[2].v(.5))
		rect.record(&t)
		rect.printf()
b = fileProbaRecord.wopen("dv")
*/
/*fileProbaRecord.printf("%f\n",node[2].v)
print dv*/
//

	finitialize(v_init)
	//load_file("plot.hoc")
	
/*//
dv = new Vector()
//print node[2].v(.5)
dv.record(&node[2].v(.5))
b = fileProbaRecord.wopen("dv")
fileProbaRecord.printf("%f\n",node[2].v)
print dv
//*/
	
	// Start simulation (t starts to go)
	// When t = START, seti() is called for the first time and since calls are
	// launched within the function, the simulation will follow its instructions
	// until t = tstop ;)
	run()
	
/*
sprint(naziv,"%s%d%s", "voltages", c, ".dat")
a = fileProba.wopen(naziv)
for i=0, axonnodes-1{
	fileProba.printf("%f\n",node[i].v)
	fileProba.printf("%f\n",node[i].vext)
}
*/
		
//printf("%s\n","ExecuteSimulation")
//printf("%d\n",apc.n)
		
		
/*// Graph
g = new Graph()
g.size(0, 10, -100, 50)
g.beginline() 
for(x=0; x<=10; x=x+0.05){   //States that x values to be plotted
                            //will go from 0 to 10 in increments
                            //of 0.1.
    g.line(x, node[2].v)       //States that the y values on the plot
                            //will be the sin of the x values.
}
g.flush()   //Actually draws the plot on the graph in the window.
//*/

	// If threshold crossed (AP generated) on both nodes (11 and 20), return 
	// mod_factor+1 (because apc.n gives number of times crossed threshold)
	// return mod_factor+0 otherwise (all this after simulation of tstop seconds of
	// course ;)
	//print apc.n
	//print apc1.n
	if (apc.n>0 && apc1.n>0){
		return 1
	} else{
		return 0
	}
}

// NTC none of the following are useful for interactive simulations
// in particular, don't automatically call quit()

/*
objref p

// save voltage and time at each time-step in node 100
objref tvec, vvec
tvec = new Vector()
vvec = new Vector()
tvec.record(&t, dt) // record time
vvec.record(&node[100].v(0.5), dt)

objref f7, f19

f7 = new File()
f19 = new File()

f7.wopen("tvec.dat")
f19.wopen("vvec.dat")

tvec.printf(f7)
vvec.printf(f19)

f7.close()
f19.close()
*/

//print "end voltage: "
//print v
/* NTC
runStopAt = 5
runStopIn = 1
t = 0 				// reset time variable
*/
// print m
// if (m==3){      // the axon fired
// print "The axon fired at the ", node2check, "th node, peak=1"}
// if (m==2){      // the axon did not fire
// print "The axon did not fire at the ", node2check, "th node, peak=0"}
// quit()


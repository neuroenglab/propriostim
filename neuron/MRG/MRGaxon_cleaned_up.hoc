/* File description ***********************************************************/
/*
2/02
Cameron C. McIntyre
SIMULATION OF PNS MYELINATED AXON

This model is described in detail in:

McIntyre CC, Richardson AG, and Grill WM. Modeling the excitability of
mammalian nerve fibers: influence of afterpotentials on the recovery
cycle. Journal of Neurophysiology 87:995-1006, 2002.

This model can not be used with NEURON v5.1 as errors in the
extracellular mechanism of v5.1 exist related to xc. The original
stimulations were run on v4.3.1. NEURON v5.2 has corrected the 
limitations in v5.1 and can be used to run this model.

Modified by Stéphanie Amati, EPFL, December 2014
*/

/* Libraries and files ********************************************************/
// Libraries
a = load_file("noload.hoc") 	// Load standard run system and other useful hoc 
				   				// libraries. (NOT needed to just get activation)

/* Parameters and variables ****************************************/

// Files to read
// fiber and simulation parameters, extracellular potentials
objectvar file_par_Vext
file_par_Vext=new File()

// Objects
// stimulation potential
objectvar V
// initialization handler
objref fih
// AP counter for middle node
objref apcMiddle
// AP counter for end node
objref apcEnd

/* Procedures and functions ***************************************************/

// Procedure to load data from files (stimulation parameters, fiber diameter and
// structure and external stmulation potential
proc load_files(){
    // Fiber parameters and voltages
    // Read in a file with following format:
	// 'D'
	// 'start'
	// 'duration'
	// 'deltai'
	// 'nbCurr'
	// 'nbNod'
	// 'nComparts'
	// 'nodeD'
	// 'paraD1'
	// 'paraD2', 
	// 'interD'
	// 'L'
	// 'nodeL'
	// 'paraL1'
	// 'paraL2'
	// 'interL'
	// 'nbLam'
	// 'bisect'
	// vector with extracellular voltages
	file_par_Vext.ropen("parameters_vext.dat")
	
	D = file_par_Vext.scanvar()
	start = file_par_Vext.scanvar()
	duration = file_par_Vext.scanvar()
	deltaI = file_par_Vext.scanvar()	
	nbCurr = file_par_Vext.scanvar()			// attention changé nom
	
	nbNod = file_par_Vext.scanvar()			// attention changé nom
	nComparts = file_par_Vext.scanvar()			// rajouté par moi
	
	nodeD = file_par_Vext.scanvar()
	paraD1 = file_par_Vext.scanvar()
	paraD2 = file_par_Vext.scanvar()
	interD = file_par_Vext.scanvar()			// attention changé nom
	
	nnL = file_par_Vext.scanvar()			// attention changé nom
	nodeL = file_par_Vext.scanvar()			// rajouté par moi
	paraL1 = file_par_Vext.scanvar()			// rajouté par moi, attention changé nom
	paraL2 = file_par_Vext.scanvar()
	interL = file_par_Vext.scanvar()
	
	nbLam = file_par_Vext.scanvar()			// attention changé nom
	bisect = file_par_Vext.scanvar()

	// Stimulation potential
	V = new Vector(nComparts*(nbNod-1)+1) 
    for i=0, nComparts*(nbNod-1) {
		V.x[i] = file_par_Vext.scanvar()
	}
	file_par_Vext.close()
}

// Load data from files (data)
load_files()

// Procedure to set constant parameters of the MRG model
proc model_globals() {	
	// General parameters
	celsius = 37		// Temperature		
	v_init = -80  		// Resting potential		

	// Topological parameters		
	axonnodes = nbNod  			
	paranodes1 = (nbNod-1)*2			// 2 MYSA per section
	paranodes2 = (nbNod-1)*2			// 2 FLUT per section
	axoninter = (nbNod-1)*6				// 6 STIN per section			
	axontotal = (nbNod-1)*nComparts + 1 // Total number of elements in fiber
				 
	// Morphological parameters	
	space_p1 = 0.002  				// Space between MYSA and ext layer [um]
	space_p2 = 0.004				// Space between FLUT and ext layer [um]
	space_i = 0.004					// Space between SLIN and ext layer [um]
	
	// Electrical parameters	
	rhoa = 0.7e6 	// Axoplasmic resistivity [ohm*um]
	mycm = 0.1 		// Myelin capacitance per lamella membrane (2 membranes per
					// lamella) [uF/cm^2]
	mygm = 0.001 	// Mylin conductance per lamella membrane (2 membranes per
					// lamella) [S/cm^2]
}

// Set MRG constant parameters
model_globals()

// Procedure to compute parameters of the MRG that are dependant of the fiber
// diameter
proc dependent_var() {
	// Fiber axonal resistivities at different levels given per section surface
	// unit [Mohm/cm]
	// 0.01 is to transform in Mohms/cm (1e-6*1e4 = 1e-2)
	Rpn0 = (rhoa*.01)/(PI*((((nodeD/2)+space_p1)^2)-((nodeD/2)^2))) 	// Little space above node layer
	Rpn1 = (rhoa*.01)/(PI*((((paraD1/2)+space_p1)^2)-((paraD1/2)^2)))	// Little space above MYSA layer
	Rpn2 = (rhoa*.01)/(PI*((((paraD2/2)+space_p2)^2)-((paraD2/2)^2)))	// Little space above FLUT layer
	Rpx = (rhoa*.01)/(PI*((((interD/2)+space_i)^2)-((interD/2)^2)))		// Little space above STIN layer
}

// Set MRG D dependent variables
dependent_var()

// Procedure to create fibers model and initialize its parameters 
// and mechanism
// Just for info, default values of extracellular: vext[0] = vext[1] = 0 mV, 
// i_membrane = 0 mA/cm^2, xraxial[1] = 1e9 Mohms/cm, xg[1] = 1e9 S/cm^2, 
// xc[1] = 0 uF/cm^2, e_extracellular = 0 mV

// Create sections composing a fiber basic structure (we have to do it here
// because we don't know the size before ;)
create node[axonnodes]
create MYSA[paranodes1]
create FLUT[paranodes2]
create STIN[axoninter]

proc initialize(){
	// Node sections
	for i=0,axonnodes-1 {
		node[i]{					
			nseg = 1
			diam = nodeD		// um
			L = nodeL			// um
			Ra = rhoa/10000		// ohm*cm (because we defined it in ohm*um)
			cm = 2				// uF/cm^2
			insert axnode		// modified HH equations		
			insert extracellular{
				xraxial = Rpn0	// Mohms/cm
				xg = 1e10		// S/cm^2
				xc = 0 			// uF/cm^2
            	//xraxial[1] = 1e20
            	// represents the axoplasm around node ?
			}
		}
	}
		
	// MYSA sections
	for i=0, paranodes1-1 {
		MYSA[i]{
			nseg = 1		
			diam = D							// um
			L = paraL1							// um
			Ra = rhoa*(1/(paraD1/D)^2)/10000	// ohm*cm with correction for
												// diameter when resistance computed ;)
			cm = 2*paraD1/D						// uf/cm^2 with correction again
			insert pas{
				g_pas = 0.001*paraD1/D			// mho/cm^2 with correction	
				e_pas = v_init					// mV
			}
			insert extracellular{
				xraxial = Rpn1					// Mohms/cm
				xg = mygm/(nbLam*2)				// s/cm^2
				xc = mycm/(nbLam*2)				// uF/cm^2 
				// represents small layer of axoplasm and myelin sheath
			}
		}
	}
	
	// FLUT sections
	for i=0, paranodes2-1 {
		FLUT[i]{
			nseg = 1							
			diam = D							// um
			L = paraL2							// um
			Ra = rhoa*(1/(paraD2/D)^2)/10000	// ohm*cm with correction
			cm = 2*paraD2/D						// uf/cm^2 with correction again
			insert pas{
				g_pas = 0.0001*paraD2/D			// mho/cm^2 with correction	
				e_pas = v_init					// mV
			}
			insert extracellular{
				xraxial = Rpn2 					// Mohms/cm
				xg = mygm/(nbLam*2) 			// s/cm^2
				xc = mycm/(nbLam*2)				// uF/cm^2 
				// represents small layer of axoplasm and myelin sheath
			}
		}
	}
	
	// STIN sections
	for i=0, axoninter-1 {
		STIN[i]{
			nseg = 1
			diam = D							// um 
			L = interL							// um
			Ra = rhoa*(1/(interD/D)^2)/10000	// ohm*cm with correction
			cm = 2*interD/D						// uf/cm^2 with correction again
			insert pas{
				g_pas=0.0001*interD/D			// mho/cm^2 with correction	
				e_pas=v_init					// mV
			}
			insert extracellular{
				xraxial = Rpx 					// Mohms/cm
				xg = mygm/(nbLam*2) 			// s/cm^2
				xc = mycm/(nbLam*2) 			// uF/cm^2 
				// represents small layer of axoplasm and myelin sheath
			}
		}
	}
	
	// Connect all sections to form fiber
	for i=0, axonnodes-2 {
		connect MYSA[2*i](0), node[i](1)
		connect FLUT[2*i](0), MYSA[2*i](1)
		connect STIN[6*i](0), FLUT[2*i](1)
		connect STIN[6*i+1](0), STIN[6*i](1)
		connect STIN[6*i+2](0), STIN[6*i+1](1)
		connect STIN[6*i+3](0), STIN[6*i+2](1)
		connect STIN[6*i+4](0), STIN[6*i+3](1)	
		connect STIN[6*i+5](0), STIN[6*i+4](1)	
		connect FLUT[2*i+1](0), STIN[6*i+5](1)
		connect MYSA[2*i+1](0), FLUT[2*i+1](1)
		connect node[i+1](0), MYSA[2*i+1](1)	
	}	
}

// Create fiber
initialize()

// Set handler
fih = new FInitializeHandler("initi()")

// Set simulation parameters
DUR = duration 			// Duration of each pulse [ms] 
START = start  			// Time of first pulse [ms]

// Procedure to initialize simulation when t = START (go to start_stim() procedure)
proc initi() {
	I_extracellular_0()
	cvode.event(start, "start_stim()")
	cvode.event(start + duration, "stop_stim()")
}

// Procedure to set simulation parameters in function of simulation state given
// by STIMON (0 = previously not stimulated, 1 = previously stimulated)
proc start_stim() {
	I_extracellular()
	cvode.re_init()
	dt = 0.001
}

proc stop_stim() {
	I_extracellular_0()
	fcurrent()
	dt = 0.001
}

// Procedure to stimulate axon extracellularly
proc I_extracellular(){
	
	// Set stimulation potential to all sections of the fiber
    for i=0, axonnodes-2{
		// start position of the current section in terms of compartments
		sectStart = i * nComparts
		node[i].e_extracellular=-V.x[sectStart]*mod_factor
		MYSA[2*i].e_extracellular=-V.x[sectStart+1]*mod_factor
		FLUT[2*i].e_extracellular=-V.x[sectStart+2]*mod_factor
		STIN[6*i].e_extracellular=-V.x[sectStart+3]*mod_factor
		STIN[6*i+1].e_extracellular=-V.x[sectStart+4]*mod_factor
		STIN[6*i+2].e_extracellular=-V.x[sectStart+5]*mod_factor
		STIN[6*i+3].e_extracellular=-V.x[sectStart+6]*mod_factor
		STIN[6*i+4].e_extracellular=-V.x[sectStart+7]*mod_factor
		STIN[6*i+5].e_extracellular=-V.x[sectStart+8]*mod_factor
		FLUT[2*i+1].e_extracellular=-V.x[sectStart+9]*mod_factor
		MYSA[2*i+1].e_extracellular=-V.x[sectStart+10]*mod_factor
	}
    
    // Set last node
    node[axonnodes-1].e_extracellular=-V.x[V.size()-1]*mod_factor  

}

// Procedure to stop stimulating axon extracellularly (I = 0)
proc I_extracellular_0(){
	// Set stimulation to zero for all sections of the fiber
	for i=0, axonnodes-2{
		node[i].e_extracellular=0
     	MYSA[2*i].e_extracellular=0
      	FLUT[2*i].e_extracellular=0
		STIN[6*i].e_extracellular=0
		STIN[6*i+1].e_extracellular=0
		STIN[6*i+2].e_extracellular=0
		STIN[6*i+3].e_extracellular=0
		STIN[6*i+4].e_extracellular=0
        STIN[6*i+5].e_extracellular=0 
        FLUT[2*i+1].e_extracellular=0
        MYSA[2*i+1].e_extracellular=0
	}
	
    // Set last node
    node[axonnodes-1].e_extracellular=0
}

// Function that launches simulation for one mod_factor given as input
func ExecuteSimulation(){ local id
	// Set simulation parameters		
	mod_factor = $1		// Set mod_factorlitude modulator as input parameter 1
	
	tstop = 1.4		// Set stopping time to 1.4ms
	dt = 0.001		// Set smod_factorling time to 0.001ms

	// Put AP counter on center of nodes in middle and end of fiber with 
	// threshold 0mv (on v, not on extracellular layers)
	// middle node
	node[int(axonnodes / 2 + .5) - 1] {
		apcMiddle = new APCount(0.5)
		apcMiddle.thresh = 0
	}
	// end node
	node[axonnodes - 1]{
		apcEnd = new APCount(0.5)
		apcEnd.thresh = 0
	}
	access node[axonnodes - 1]
	
	// Performs initialization in several steps:
	// - sets t = 0
	// - initialize all sections membrane potential with v_init (node/paranode)
	// - calls FInitializeHandlers: here we have only fih which points on the 
	//   procedure initi() 
	// - executes all INITIAL blocks of the sections mechanisms	(.mod)

	finitialize(v_init)
	
	// Start simulation (t starts to go)
	// When t = START, seti() is called for the first time and since calls are
	// launched within the function, the simulation will follow its instructions
	// until t = tstop ;)
	run()
	
	// If threshold crossed (AP generated) on both nodes (11 and 20), return 
	// mod_factor+1 (because apcMiddle.n gives number of times crossed threshold)
	// return mod_factor+0 otherwise (all this after simulation of tstop seconds of
	// course ;)
	//print apcMiddle.n
	//print apcEnd.n
	if (apcMiddle.n>0 && apcEnd.n>0){
		return 1
	} else{
		return 0
	}
}

/* Main ***********************************************************************/
// Launch simulations until fiber is activated

if (bisect) {
	// BISECTION
	minActive = nbCurr+1  // min value tested positive
	maxInactive = 0  // max value tested negative
	while (minActive - maxInactive > 1) {
		i_stim = int((minActive + maxInactive) / 2)
		mod_factor = i_stim*deltaI
		// print mod_factor
		activation = ExecuteSimulation(mod_factor)
		if(activation) {
			minActive = i_stim
		} else {
			maxInactive = i_stim
		}
	}
} else {
	i_stim = 1
	minActive = 0
	activation = 0
	while (!activation && i_stim <= nbCurr) {
		mod_factor = i_stim*deltaI
		// print mod_factor
		activation = ExecuteSimulation(mod_factor)
		if (activation) {
			minActive = i_stim
		}
		i_stim+=1
	}
}

print "threshold current step: ", minActive % (nbCurr + 1)